<html>
<style type="text/css"><!--
 body { margin-left: 10%; margin-right: 10%; }
 h1 { font-size: 150%;  margin-left: 3%; page-break-before: always;}
 h2 { font-size: 120%;  margin-left: 1%; }
 h3 { font-size: 110%; margin-left: 0%; }
 ul { list-style: none; }
 ul { padding: 0 0 0 1.5em; }
 li { padding: 0 0 0.5em 0; }
 em {font-size: 133%; font-family:monospace}

--></style>
<body>

<p>
<center><img src="nexus_logo_midi.png"></center>
<p>
<h2>Index:</h2>
<p>
<ul>

<li><a href="#picture">Big picture</a></li>
<li><a href="#struct">Structures and interfaces</a></li>
<ul>
 <li><a href="#vfile">VFile</a></li>
 <li><a href="#crude">Crude</a></li>
 <li><a href="#pchain">PChain</a></li>
 <li><a href="#nexus">Nexus</a></li>
 <li><a href="#bmt">Bmt</a></li>
</ul>
<li><a href="#algo">Algorithms</a></li>
<ul>
 <li><a href="#plyto">Plys to Crude</a></li>
 <li><a href="#crudeto">Crude to PChain</a></li>
 <li><a href="#crudepchainto">Crude + Pchain to Nexus</a></li>
 <li><a href="#nexusto">Nexus to Bmt</a></li>
</ul>
</ul>


<a name="picture"><h1>Big picture</h1></a>
<a name="struct"><h1>Structures and interfaces</h1></a>

<a name="vfile"><h2>VFile</h2></a>
VFile dovrebbe avere piu' o meno la stessa interfaccia di <em>vector</em>
ma usare un file per storare i dati (un mmapping, ma non limitato a 4Gb).<br>

<a name="crude"><h2>Crude</h2></a>
Crude e' un formato tipo il ply... solo che usa dei VFile per 
storare i dati.(3 unsigned int per una faccia e 3 float per un vertice)<br>
Per cui e' composto di 3 files almeno: header (numero di facce,
vertici e Bounding box), file dei vertici, file delle facce ed
opzionalmente file degli attributi dei vertici e delle facce.<br>
Come interfaccia e' sufficente che dia accesso casuale a facce e vertici...
<a name="pchain"><h2>PChain</h2></a>
Sta per 'partition  chain' cioe' una catena di partizioni dello
spazio.<br>
Una <em>PChain</em> detto in matematichese e' una funzione da 
[0..L] X R^3 -> N (cioe' dato un livello e un punto nello spazio
restituisce un numero naturale. (una patch)<br>
Oltre a questo va aggiunta una funzione che dato un punto e una patch
ne restituisce la distanza (o un valore 'equivalente').<br>
Si deve poter salvare su disco e recuperare una pchain<br>

<a name="remap"><h2>Remap</h2></a>
E' composta da 3 files:<br>
indice delle patches: per ogni patch il numero di vertici, di facce e
di bordi<br>
 vertici -> lista di patches: per ogni vertice una lista di patch
di cui fa parte (se sono + di 1 e' ovviamente di bordo.<br>
facce->patches: per ogni faccia un intero che dice in quale patch
sta.<br>


<a name="nexus"><h2>Nexus</h2></a>
E' una struttura con 3 files: 'index', 'patches' e 'borders'.<br>
'Index' contiene l'indice delle patches: per ogni patch viene storato
offset, size (ma questa potrebbe essere storata direttamente nei
files?) dei dati geometrici nel file delle patches e dei bordi nel
file dei borders, oltre alla bounding sphere.<br>
'Patches' e' un VFile di chunks da 4k dove i dati geometrici di una
patch occupano un numero intero di chunks. P.S. Come ce la caviamo con
gli attributi dei vertici e delle facce?<br>
'Borders' e' un VFile di 'links' dove ogni link fa riferimento ad un
vertice di bordo tra la patch A (V_a) e la B (V_b) e contiene
(V_a, V_b, B) (A e' implicito). L'informazione e' replicata nei bordi
relativi a B con (V_b, V_a, A)<br>

<a name="bmt"><h2>Bmt</h2></a>
Bmt (batched multi triangulation) e' il formato per la
multirisoluzione:<br>
E' un vettore di 'Cell' scritti su disco + un 'Index' e una 'History'.
Cell contiene i dati da visualizzare: vertici e strip (e altro?).<br>
Index contiene per ogni cell 'offset' per trovare la cell
corrispondente, error e bounding sphere (e per il face o vertex
count?).<br>
History e' la storia della multirisoluzione.<br>

<a name="algo"><h1>Algorithms</h1></a>
<a name="plyto"><h2>Plys to Crude</h2></a>
Si copiano i vertici un ply dopo l'altro nel crude.<br>
Per le facce si copiano sommando un offset ai vertici<br>
Se si montano insieme piu' ply i vertici rimangono duplicati.<br>
E' piu' semplice fare il join dentro Nexus.<br>

<a name="crudeto"><h2>Crude + PChain to Remap</h2></a>
Come prima cosa si costruisce il pchain passandogli il Crude.<br>
Asegnamo per ogni faccia la sua patch al livello 0.<br>
Per ogni patch sappiamo quante ce ne sono.<br>
Ridistribuiamo le patch troppo piccole (e rimappiamo i numeri delle
patches per rimuovere i buchi (anche dentro il PChain).<br>
Per risparmiare nella stessa passata ci segnamo dove vanno i vertici<br>
Poi facciamo un'altra passate per contare i bordi<br>
Infine si sortano le facce secondo l'ordine delle patches.<br>

<a name="crudepchainto"><h2>Crude + Remap to Nexus</h2></a>
Per ogni patch raccogliamo le facce, e i vertici (ma non li
unifichiamo) e costruiamo una patch nel Nexus.<br>
Ci dobbiamo segnare i bordi mano a mano che lo facciamo:
per ogni patch ci salviamo una lista di triplette: il numero assoluto
del vertice di bordo, il numero relativo nella patch che stiamo
salvando, e il numero della patch (o delle patch) con la quale
confina.<br>
Queste informazioni le tiriamo fuori dal Remap dei vertici<br>
Una volta salvate tutte le patches ci smazziamo i bordi:
per ogni patch prendiamo quella lista e la incrociamo con quella
delle patches confinanti per costruire i bordi da passare a nexus.<br>

<a name="nexusto"><h2>Nexus + PChain to Bmt</h2></a>
Per costruire il file multirisoluzione aggiungeremo semplicemente
nuove patches al file nexus.<br>
Ad ogni passo selezioniamo un gruppo di patches (il PChain ci dice i
gruppi), li joiniamo insieme usando i bordi per riunificare i vertici
e per marcare i bordi esterni.<br>
Poi semplifichiamo e splittiamo (e sempre il PChain ci dice quali
nuove patches creare), ridistribuiamo le patches troppo piccole.<br>
E aggiungiamo le nuove patches al Nexus, e i nuovi bordi.<br>
Ci salviamo anche la storia da qualche parte.<br>
</body>
</html>
